## app.js 역할

- 프로젝트의 **메인 라우터** 역할을 한다.
- 클라이언트의 요청이 가장 먼저 도착하는 진입 지점이다.

### 라우터가 로직까지 모두 수행하면 생기는 문제

- 프로젝트 규모가 커질수록 코드가 복잡해진다.
- 가독성이 크게 떨어진다.
- 오류 발생 시 트러블슈팅이 어려워진다.

 따라서 **라우터와 비즈니스 로직을 분리**하는 것이 중요하다.

---

## 컨트롤러

- 프로젝트에서 **매니저 역할**을 하는 파일이다.
- 어떤 작업을 누구에게 시킬지 알고 있다.

### 동작 흐름

👉 사용자 요청 발생

→ Router가 요청을 받음

→ Controller가 요청을 분석하고 적절한 로직(서비스 / DB 등)에 작업을 위임

→ 결과를 받아 응답 반환

비유:

> Router = 안내 데스크
> 
> 
> Controller = 매니저
> 
> Service / DB = 실제 일을 하는 직원
> 

이 구조를 사용하면:

- 코드 역할이 명확해지고
- 유지보수가 쉬워지며
- 확장성이 좋아진다.

---

## 📌 crypto (비밀번호 암호화)

- Node.js에서 제공하는 암호화 모듈이다.
- 사용자 비밀번호를 **그대로 저장하지 않고**, 안전하게 보호하기 위해 사용한다.

### 🔑 핵심 개념

### ✅ Salt

- 비밀번호에 추가되는 **랜덤 문자열**
- 동일한 비밀번호라도 서로 다른 해시값이 생성된다.
- 해킹 시 레인보우 테이블 공격을 방어할 수 있다.

```jsx
const salt = crypto.randomBytes(64).toString('base64');
```

---

### ✅ Hashing (해싱)

- 비밀번호를 복구할 수 없는 문자열로 변환하는 과정

```jsx
const hashPassword = crypto
  .pbkdf2Sync(password, salt, 10000, 64, 'sha512')
  .toString('base64');
```

👉 주요 옵션 설명:

- **password** : 사용자가 입력한 비밀번호
- **salt** : 랜덤 문자열
- **10000** : 반복 횟수 (높을수록 보안 ↑, 속도 ↓)
- **64** : 결과 바이트 길이
- **sha512** : 해시 알고리즘

---

## 회원가입 시 처리 과정

1️⃣ 사용자가 비밀번호 입력

2️⃣ salt 생성

3️⃣ 비밀번호 + salt → 해시 생성

4️⃣ **hash 값과 salt를 DB에 저장**

**원본 비밀번호는 절대 저장하지 않는다.**

---

## 로그인 시 처리 과정

1️⃣ 사용자가 이메일 / 비밀번호 입력

2️⃣ DB에서 해당 사용자의 salt 조회

3️⃣ 입력한 비밀번호 + salt로 다시 해싱

4️⃣ DB에 저장된 hash와 비교

두 값이 같다면 로그인 성공.

---

## 🚀 한 줄 정리

👉 **라우터는 길 안내만 하고, 컨트롤러가 일을 관리하며, 비밀번호는 반드시 암호화해서 저장한다.**
